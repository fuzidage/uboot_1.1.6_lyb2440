diff -urN u-boot-1.1.6/board/lyb2440/boot_init.c uboot_1.1.6_lyb2440/board/lyb2440/boot_init.c
--- u-boot-1.1.6/board/lyb2440/boot_init.c	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/boot_init.c	2019-12-05 17:47:55.205691591 -0800
@@ -0,0 +1,223 @@
+#include <common.h>
+#include <s3c2410.h>
+#include <nand.h>
+
+#define BUSY            	(1<<0)
+#define NAND_PAGE_SIZE		2048
+#define NAND_PAGE_MASK		(NAND_PAGE_SIZE - 1)
+
+/* copy from /board/smdk2410/smdk2410.c*/ 
+static inline void delay (unsigned long loops)
+{
+    __asm__ volatile ("1:\n"
+      "subs %0, %1, #1\n"
+      "bne 1b":"=r" (loops):"0" (loops));
+}
+
+
+/* 等待NAND Flash就绪 */
+static void s3c2440_wait_idle(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;
+
+    while(!(*p & BUSY))
+        delay(10);
+}
+
+/* 发出片选信号 */
+static void s3c2440_nand_select_chip(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT &= ~(1<<1);
+}
+
+/* 取消片选信号 */
+static void s3c2440_nand_deselect_chip(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    s3c2440nand->NFCONT |= (1<<1);
+}
+
+/* 发出命令 */
+static void s3c2440_write_cmd(int cmd)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
+    *p = cmd;
+}
+
+
+
+/* 发出地址 */
+static void s3c2440_write_addr(unsigned int addr)
+{
+    int i;
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
+	int col, page;
+
+	col  = addr & NAND_PAGE_MASK;
+	page = addr / NAND_PAGE_MASK;
+	
+    *p = col & 0xff;			/* Column Address A0~A7 */
+    for(i=0; i<10; i++);		
+    *p = (col >> 8) & 0x0f;		/* Column Address A8~A11 */
+    for(i=0; i<10; i++);
+    *p = page & 0xff;			/* Row Address A12~A19 */
+    for(i=0; i<10; i++);
+    *p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
+    for(i=0; i<10; i++);
+    *p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
+    for(i=0; i<10; i++);
+}
+
+/* 读取数据 */
+static unsigned char s3c2440_nand_read(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFDATA;
+    return *p;
+}
+
+
+/* S3C2440的NAND Flash操作函数 */
+/* 复位 */
+static void s3c2440_nand_reset(void)
+{
+    s3c2440_nand_select_chip();
+    s3c2440_write_cmd(0xff);  // 复位命令
+    s3c2440_wait_idle();
+    s3c2440_nand_deselect_chip();
+}
+
+
+
+/* 初始化NAND Flash */
+void lyb_nand_init(void)
+{
+	S3C2440_NAND * s3c2440nand = (S3C2440_NAND *)0x4e000000;
+
+#define TACLS   0
+#define TWRPH0  3
+#define TWRPH1  0
+
+	/* 设置时序 */
+    s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+    /* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
+    s3c2440nand->NFCONT = (1<<4)|(1<<1)|(1<<0);
+
+	/* 复位NAND Flash */
+	s3c2440_nand_reset();
+}
+
+
+
+
+/* 读函数  */
+void lyb_nand_read(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+    
+    if ((start_addr & NAND_PAGE_MASK) || (size & NAND_PAGE_MASK)) {
+        return ;    /* 地址或长度没有页对齐 */
+    }
+
+    /* 选中芯片 */
+	s3c2440_nand_select_chip();
+
+	
+    for(i=start_addr; i < (start_addr + size); i += NAND_PAGE_SIZE) {
+		/* 发出READ(0)命令 */
+		s3c2440_write_cmd(0);
+
+   		/* Write Address */
+		s3c2440_write_addr(i);
+
+		/*发出30命令*/
+	  	s3c2440_write_cmd(0x30);
+
+		/*等待空闲*/
+		s3c2440_wait_idle();
+
+		/*开始1page数据传输*/
+		for(j=0; j < NAND_PAGE_SIZE; j++)
+			*buf++ = s3c2440_nand_read();//传输1byte数据，nand的8位数据线传输命令、地址、数据
+		
+    }
+
+    /* 取消片选信号 */
+    s3c2440_nand_deselect_chip();
+    
+    return ;
+}
+
+int bBootFrmNORFlash(void)
+{
+    volatile unsigned int *pdw = (volatile unsigned int *)0;
+    unsigned int dwVal;
+    
+    /*
+     * 无论是从NOR Flash还是从NAND Flash启动，
+     * 地址0处为指令"b	Reset", 机器码为0xEA00000B，
+     * 对于从NAND Flash启动的情况，其开始4KB的代码会复制到CPU内部4K内存中，
+     * 对于从NOR Flash启动的情况，NOR Flash的开始地址即为0。
+     * 对于NOR Flash，必须通过一定的命令序列才能写数据，
+     * 所以可以根据这点差别来分辨是从NAND Flash还是NOR Flash启动:
+     * 向地址0写入一个数据，然后读出来，如果没有改变的话就是NOR Flash
+     */
+
+    dwVal = *pdw;       
+    *pdw = 0x12345678;
+    if (*pdw != 0x12345678)
+    {
+        return 1;
+    }
+    else//nand启动，0地址对应sram
+    {
+        *pdw = dwVal;
+        return 0;
+    }
+}
+
+int CopyCode2Ram(unsigned long start_addr, unsigned char *buf, int size)
+{
+    int i, remain_size = size % 4;
+    unsigned int *p_dest = (unsigned int *)buf;
+    unsigned int *p_src  = (unsigned int *)start_addr;
+    unsigned char *p_remain_src, *p_remain_dest;
+	
+    if (bBootFrmNORFlash())
+    {
+        /* 从 NOR Flash启动 */
+        for (i = 0; i < size / 4; i++)
+        {
+            *p_dest++ = *p_src++;
+        }
+
+		p_remain_src  = (unsigned char *)p_src;
+		p_remain_dest = (unsigned char *)p_dest;
+		while (remain_size--)
+		{
+			*p_remain_dest++ = *p_remain_src++;
+		}
+        return 0;
+    }
+    else
+    {
+        /* 初始化NAND Flash */
+		lyb_nand_init();
+        /* 从 NAND Flash启动 */
+        lyb_nand_read(buf, start_addr, (size + NAND_PAGE_MASK)&~(NAND_PAGE_MASK));
+		return 0;
+    }
+}
+
+
+
+
+
+
diff -urN u-boot-1.1.6/board/lyb2440/config.mk uboot_1.1.6_lyb2440/board/lyb2440/config.mk
--- u-boot-1.1.6/board/lyb2440/config.mk	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/config.mk	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,25 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# SAMSUNG SMDK2410 board with S3C2410X (ARM920T) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+#
+
+#
+# SMDK2410 has 1 bank of 64 MB DRAM
+#
+# 3000'0000 to 3400'0000
+#
+# Linux-Kernel is expected to be at 3000'8000, entry 3000'8000
+# optionally with a ramdisk at 3080'0000
+#
+# we load ourself to 33F8'0000
+#
+# download area is 3300'0000
+#
+
+
+TEXT_BASE = 0x33F80000
diff -urN u-boot-1.1.6/board/lyb2440/flash.c uboot_1.1.6_lyb2440/board/lyb2440/flash.c
--- u-boot-1.1.6/board/lyb2440/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/flash.c	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,433 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+
+	return rc;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+}
diff -urN u-boot-1.1.6/board/lyb2440/lowlevel_init.S uboot_1.1.6_lyb2440/board/lyb2440/lowlevel_init.S
--- u-boot-1.1.6/board/lyb2440/lowlevel_init.S	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/lowlevel_init.S	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,170 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+/*内存控制器相关设置*/
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+/*配置位宽*/
+#define B1_BWSCON	  	(DW16)
+#define B2_BWSCON	  	(DW16)
+//#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B3_BWSCON	  	(DW16 + UBLB)		//10m网卡CS8900A
+#define B4_BWSCON	  	(DW16 + WAIT + UBLB)	//网卡dm9000，修改数据宽度为16位，使用WAIT和nBE信号
+#define B5_BWSCON	  	(DW8)			//扩展串口
+#define B6_BWSCON	  	(DW32)			//sdram
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x0	/*  0clk */
+#define B3_Tacp		 	0x3     /*  6clk */
+#define B3_PMC		 	0x0	/* normal */
+
+/*根据外接的DM9000 网卡配置bank4时序*/
+#define B4_Tacs		 	0x0	/*  0clk DM9000*/
+#define B4_Tcos		 	0x3	/*  4clk */
+#define B4_Tacc		 	0x7	/* 14clk */
+#define B4_Tcoh		 	0x1	/*  1clk */
+#define B4_Tah		 	0x3	/*  4clk */
+#define B4_Tacp		 	0x6 	/*  6clk */
+#define B4_PMC		 	0x0	/* normal */
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define B6_MT		 	0x3	/* SDRAM */
+#define B6_Trcd	 	 	0x1
+#define B6_SCAN		 	0x1	/* 9bit */
+
+#define B7_MT		 	0x3	/* SDRAM */
+#define B7_Trcd		 	0x1	/* 3clk */
+#define B7_SCAN		 	0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp			0x0	/* 2clk */
+#define Trc			0x3	/* 7clk */
+#define Tchr		 	0x2	/* 3clk */
+#define REFCNT		 	0x4f4	/* period=7.8125us, HCLK=100Mhz, (2048+1-7.8125*100) 根据sdram的刷新性能配置*/
+/**************************************/
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+.globl lowlevel_init
+lowlevel_init:
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0xb1		//BANKSIZE
+    .word 0x30
+    .word 0x30
diff -urN u-boot-1.1.6/board/lyb2440/lyb2440.c uboot_1.1.6_lyb2440/board/lyb2440/lyb2440.c
--- u-boot-1.1.6/board/lyb2440/lyb2440.c	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/lyb2440.c	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,141 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <s3c2410.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define FCLK_SPEED 1
+
+#if FCLK_SPEED==0		/* Fout = 203MHz, Fin = 12MHz for Audio */
+#define M_MDIV	0xC3
+#define M_PDIV	0x4
+#define M_SDIV	0x1
+#elif FCLK_SPEED==1		/* Fout = 202.8MHz */
+#define M_MDIV	0xA1
+#define M_PDIV	0x3
+#define M_SDIV	0x1
+#endif
+
+#define USB_CLOCK 1
+
+#if USB_CLOCK==0
+#define U_M_MDIV	0xA1
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x1
+#elif USB_CLOCK==1
+#define U_M_MDIV	0x48
+#define U_M_PDIV	0x3
+#define U_M_SDIV	0x2
+#endif
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+#define S3C2440_MPLL_400MHZ 	((0x5c<<12)|(0x02<<4)|(0x01))  //HJ 400MHZ
+//#define S3C2440_UPLL_48MHZ  	((0x38<<12)|(0x02<<4)|(0x02))   //HJ 100MHZ
+#define S3C2440_CLKDIV      	0x05
+
+int board_init (void)
+{
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	clk_power->CLKDIVN = S3C2440_CLKDIV;
+	
+	/* change to asynchronous bus mode */
+		__asm__( "mrc p15, 0, r1, c1, c0, 0\n"
+				"orr r1, r1, #0xc0000000\n"
+				"mcr p15, 0, r1, c1, c0, 0\n"
+				:::"r1"
+				);
+
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->LOCKTIME = 0xFFFFFF;
+
+	/* configure MPLL */
+	//clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+	clk_power->MPLLCON = S3C2440_MPLL_400MHZ;
+	
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	//clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+	//clk_power->UPLLCON = S3C2440_UPLL_48MHZ;
+	
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+
+	/* set up the I/O ports */
+	gpio->GPACON = 0x007FFFFF;
+	gpio->GPBCON = 0x00044555;
+	gpio->GPBUP = 0x000007FF;
+	gpio->GPCCON = 0xAAAAAAAA;
+	gpio->GPCUP = 0x0000FFFF;
+	gpio->GPDCON = 0xAAAAAAAA;
+	gpio->GPDUP = 0x0000FFFF;
+	gpio->GPECON = 0xAAAAAAAA;
+	gpio->GPEUP = 0x0000FFFF;
+	gpio->GPFCON = 0x000055AA;
+	gpio->GPFUP = 0x000000FF;
+	gpio->GPGCON = 0xFF95FFBA;
+	gpio->GPGUP = 0x0000FFFF;
+	gpio->GPHCON = 0x002AFAAA;
+	gpio->GPHUP = 0x000007FF;
+
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_SMDK2440;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+/*
+	gpio->GPFCON &= ~((3<<8) | (3<<10) | (3<<12));
+	gpio->GPFCON |=  ((1<<8) | (1<<10) | (1<<12));
+	gpio->GPFDAT &= ~(7<<4);
+*/
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff -urN u-boot-1.1.6/board/lyb2440/Makefile uboot_1.1.6_lyb2440/board/lyb2440/Makefile
--- u-boot-1.1.6/board/lyb2440/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/Makefile	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= lyb2440.o boot_init.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-1.1.6/board/lyb2440/u-boot.lds uboot_1.1.6_lyb2440/board/lyb2440/u-boot.lds
--- u-boot-1.1.6/board/lyb2440/u-boot.lds	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/board/lyb2440/u-boot.lds	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,58 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  board/lyb2440/boot_init.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -urN u-boot-1.1.6/common/env_common.c uboot_1.1.6_lyb2440/common/env_common.c
--- u-boot-1.1.6/common/env_common.c	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/common/env_common.c	2019-12-05 17:47:55.209691591 -0800
@@ -45,6 +45,7 @@
 #endif
 
 #undef DEBUG_ENV
+#define DEBUG_ENV
 #ifdef DEBUG_ENV
 #define DEBUGF(fmt,args...) printf(fmt ,##args)
 #else
diff -urN u-boot-1.1.6/common/main.c uboot_1.1.6_lyb2440/common/main.c
--- u-boot-1.1.6/common/main.c	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/common/main.c	2019-12-05 17:47:55.209691591 -0800
@@ -381,12 +381,11 @@
 # endif
 	}
 #endif /* CONFIG_PREBOOT */
-
 #if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
-	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
+	printf ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
 
 # ifdef CONFIG_BOOT_RETRY_TIME
 	init_cmd_timeout ();
@@ -402,7 +401,7 @@
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv ("bootcmd");
 
-	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
+	printf ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
 	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
diff -urN u-boot-1.1.6/common/miiphyutil.c uboot_1.1.6_lyb2440/common/miiphyutil.c
--- u-boot-1.1.6/common/miiphyutil.c	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/common/miiphyutil.c	2019-12-05 17:47:55.209691591 -0800
@@ -37,9 +37,9 @@
 
 /* local debug macro */
 #define MII_DEBUG
-#undef MII_DEBUG
+//#undef MII_DEBUG
 
-#undef debug
+//#undef debug
 #ifdef MII_DEBUG
 #define debug(fmt,args...)	printf (fmt ,##args)
 #else
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/Makefile uboot_1.1.6_lyb2440/cpu/arm920t/s3c24x0/Makefile
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/Makefile	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/cpu/arm920t/s3c24x0/Makefile	2019-12-05 17:47:55.209691591 -0800
@@ -26,7 +26,7 @@
 LIB	= $(obj)lib$(SOC).a
 
 COBJS	= i2c.o interrupts.o serial.o speed.o \
-	  usb_ohci.o
+	  usb_ohci.o nand_flash.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash.c uboot_1.1.6_lyb2440/cpu/arm920t/s3c24x0/nand_flash.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/nand_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/cpu/arm920t/s3c24x0/nand_flash.c	2019-12-05 17:47:55.209691591 -0800
@@ -0,0 +1,104 @@
+/*
+ * copy from drivers/mtd/nand/s3c2410.c of kernel 2.6.13
+ */
+
+#include <common.h>
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND) && !defined(CFG_NAND_LEGACY)
+#include <s3c2410.h>
+#include <nand.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define S3C2440_NFSTAT_READY    (1<<0)
+#define S3C2440_NFCONT_nFCE     (1<<1)
+
+/* command and control functions */
+static void s3c2440_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+    struct nand_chip *chip = mtd->priv;
+
+    switch (cmd) {
+    case NAND_CTL_SETNCE://nCE片选
+    case NAND_CTL_CLRNCE://取消片选
+        printf("%s: called for NCE\n", __FUNCTION__);
+        break;
+
+    case NAND_CTL_SETCLE://CLE命令锁存
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFCMD;
+        break;
+
+    case NAND_CTL_SETALE://ALE地址锁存
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFADDR;
+        break;
+
+        /* NAND_CTL_CLRCLE: */
+        /* NAND_CTL_CLRALE: */
+    default:
+        chip->IO_ADDR_W = (void *)&s3c2440nand->NFDATA;
+        break;
+    }
+}
+
+/* s3c2440_nand_devready()
+ *
+ * returns 0 if the nand is busy, 1 if it is ready
+ */
+static int s3c2440_nand_devready(struct mtd_info *mtd)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    return (s3c2440nand->NFSTAT & S3C2440_NFSTAT_READY);
+}
+
+/*
+ * Nand flash hardware initialization:
+ * Set the timing, enable NAND flash controller
+ */
+static void s3c2440_nand_inithw(void)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+
+    /* Set flash memory timing */
+    s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
+    /* Initialize ECC, enable chip select, NAND flash controller enable */
+    s3c2440nand->NFCONT = (1<<4)|(0<<1)|(1<<0);
+}
+
+/* select chip, for s3c2440 */
+static void s3c2440_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    if (chip == -1) {
+        s3c2440nand->NFCONT |= S3C2440_NFCONT_nFCE;//deselect
+    } else {
+        s3c2440nand->NFCONT &= ~S3C2440_NFCONT_nFCE;
+    }
+}
+
+/*
+ * Called by drivers/nand/nand.c, initialize the interface of nand flash
+ */
+void board_nand_init(struct nand_chip *chip)
+{
+    S3C2440_NAND * const s3c2440nand = S3C2440_GetBase_NAND();
+
+    s3c2440_nand_inithw();//初始化nand控制器
+
+    chip->IO_ADDR_R    = (void *)&s3c2440nand->NFDATA;
+    chip->IO_ADDR_W    = (void *)&s3c2440nand->NFDATA;
+    chip->hwcontrol    = s3c2440_nand_hwcontrol; //设置nand控制器向nand发送的信号类型
+    chip->dev_ready    = s3c2440_nand_devready;
+    chip->select_chip  = s3c2440_nand_select_chip;
+    chip->options      = 0;
+
+    chip->eccmode       = NAND_ECC_SOFT;
+}
+
+#endif
diff -urN u-boot-1.1.6/cpu/arm920t/s3c24x0/speed.c uboot_1.1.6_lyb2440/cpu/arm920t/s3c24x0/speed.c
--- u-boot-1.1.6/cpu/arm920t/s3c24x0/speed.c	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/cpu/arm920t/s3c24x0/speed.c	2019-12-05 17:47:55.209691591 -0800
@@ -41,6 +41,8 @@
 #define MPLL 0
 #define UPLL 1
 
+DECLARE_GLOBAL_DATA_PTR;
+
 /* ------------------------------------------------------------------------- */
 /* NOTE: This describes the proper use of this file.
  *
@@ -66,8 +68,9 @@
     m = ((r & 0xFF000) >> 12) + 8;
     p = ((r & 0x003F0) >> 4) + 2;
     s = r & 0x3;
-
-    return((CONFIG_SYS_CLK_FREQ * m) / (p << s));
+	
+	//参考S3C2440芯片手册上的公式：PLL=(2 * m * Fin)/(p * 2s)
+    return((CONFIG_SYS_CLK_FREQ * m * 2) / (p << s));
 }
 
 /* return FCLK frequency */
@@ -76,22 +79,67 @@
     return(get_PLLCLK(MPLL));
 }
 
+#define S3C2440_CLKDIVN_PDIVN			(1<<0)
+#define S3C2440_CLKDIVN_HDIVN_MASK		(3<<1)
+#define S3C2440_CLKDIVN_HDIVN_1			(0<<1)
+#define S3C2440_CLKDIVN_HDIVN_2			(1<<1)
+#define S3C2440_CLKDIVN_HDIVN_4_8		(2<<1)
+#define S3C2440_CLKDIVN_HDIVN_3_6		(3<<1)
+
 /* return HCLK frequency */
 ulong get_HCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv = clk_power->CLKDIVN;
+    int hdiv = 1;
 
-    return((clk_power->CLKDIVN & 0x2) ? get_FCLK()/2 : get_FCLK());
+    switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+    case S3C2440_CLKDIVN_HDIVN_1:
+        hdiv = 1;
+        break;
+    case S3C2440_CLKDIVN_HDIVN_2:
+        hdiv = 2;
+        break;
+	case S3C2440_CLKDIVN_HDIVN_4_8://还需继续分辨
+        hdiv = 4;
+		break;
+	case S3C2440_CLKDIVN_HDIVN_3_6://还需继续分辨
+        hdiv = 3;
+		break;
+    }
+
+    return get_FCLK() / hdiv;
 }
 
 /* return PCLK frequency */
 ulong get_PCLK(void)
 {
     S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+    unsigned long clkdiv;
+    int hdiv = 1;
+ 
+    clkdiv = clk_power->CLKDIVN;
+
+    switch (clkdiv & S3C2440_CLKDIVN_HDIVN_MASK) {
+    case S3C2440_CLKDIVN_HDIVN_1:
+        hdiv = 1;
+        break;
+
+    case S3C2440_CLKDIVN_HDIVN_2:
+        hdiv = 2;
+        break;
+	case S3C2440_CLKDIVN_HDIVN_4_8://还需继续分辨
+	    hdiv = 4;
+		break;
+	case S3C2440_CLKDIVN_HDIVN_3_6://还需继续分辨
+        hdiv = 3;
+		break;
+    }
 
-    return((clk_power->CLKDIVN & 0x1) ? get_HCLK()/2 : get_HCLK());
+    return get_FCLK() / hdiv / ((clkdiv & S3C2440_CLKDIVN_PDIVN)? 2:1);    
 }
 
+
 /* return UCLK frequency */
 ulong get_UCLK(void)
 {
diff -urN u-boot-1.1.6/cpu/arm920t/start.S uboot_1.1.6_lyb2440/cpu/arm920t/start.S
--- u-boot-1.1.6/cpu/arm920t/start.S	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/cpu/arm920t/start.S	2019-12-05 17:47:55.209691591 -0800
@@ -112,20 +112,24 @@
 	 * set the cpu to SVC32 mode
 	 */
 	mrs	r0,cpsr
-	bic	r0,r0,#0x1f
+	bic	r0,r0,#0x1f //低五位清零
 	orr	r0,r0,#0xd3
 	msr	cpsr,r0
 
 /* turn off the watchdog */
-#if defined(CONFIG_S3C2400)
-# define pWTCON		0x15300000
-# define INTMSK		0x14400008	/* Interupt-Controller base addresses */
-# define CLKDIVN	0x14800014	/* clock divisor register */
+#if defined(CONFIG_S3C2400) 
+#define pWTCON		0x15300000
+#define INTMSK		0x14400008	/* Interupt-Controller base addresses */
+#define CLKDIVN		0x14800014	/* clock divisor register */
+
 #elif defined(CONFIG_S3C2410)
-# define pWTCON		0x53000000
-# define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
-# define INTSUBMSK	0x4A00001C
-# define CLKDIVN	0x4C000014	/* clock divisor register */
+#define pWTCON		0x53000000
+#define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
+#define INTSUBMSK	0x4A00001C
+#define CLKDIVN		0x4C000014	/* clock divisor register */
+#define LOCKTIME	0x4C000000	/* R/W, PLL lock time count register */
+#define MPLLCON		0x4C000004	/* R/W, MPLL configuration register */
+#define S3C2440_MPLL_400MHZ		((0x5c<<12)|(0x01<<4)|(0x01))
 #endif
 
 #if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410)
@@ -139,17 +143,31 @@
 	mov	r1, #0xffffffff
 	ldr	r0, =INTMSK
 	str	r1, [r0]
-# if defined(CONFIG_S3C2410)
-	ldr	r1, =0x3ff
+	
+#if defined(CONFIG_S3C2410)	//添加s3c2440的中断禁止部分
+	ldr	r1, =0x7fff	//根据2440芯片手册，INTSUBMSK寄存器有15位可用
 	ldr	r0, =INTSUBMSK
 	str	r1, [r0]
-# endif
+#endif
 
-	/* FCLK:HCLK:PCLK = 1:2:4 */
-	/* default FCLK is 120 MHz ! */
+	/* FCLK:HCLK:PCLK = 1:4:8 */
 	ldr	r0, =CLKDIVN
-	mov	r1, #3
+	mov	r1, #5
 	str	r1, [r0]
+
+	mrc p15, 0, r1, c1, c0, 0		// read ctrl register 
+	orr r1, r1, #0xc0000000 		// Asynchronous	
+	mcr p15, 0, r1, c1, c0, 0		// write ctrl register
+
+    ldr r0,=LOCKTIME
+    ldr r1,=0xffffff
+    str r1,[r0]
+    
+
+    // Configure MPLL
+    ldr r0,=MPLLCON          
+    ldr r1,=S3C2440_MPLL_400MHZ
+    str r1,[r0]
 #endif	/* CONFIG_S3C2400 || CONFIG_S3C2410 */
 
 	/*
@@ -160,16 +178,42 @@
 	bl	cpu_init_crit
 #endif
 
+	/* Set up the stack						    */
+/* -------------------  0x3400,0000
+** |	512k（uboot）  |
+** -------------------  <-- _TEXT_BASE(0x33F8,0000)
+** | CFG_MALLOC_LEN  |
+** -------------------
+** |CFG_GBL_DATA_SIZE|  gd info(128byte)
+** -------------------
+** |		12byte	 |
+** -------------------  <-- sp
+** |		...	 	 |
+** ------------------- 0x3000,0000
+*/
+
+stack_setup:
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+
+/*为了支持nand启动，将设置栈放在重定位之前，以便于用c语言实现nand初始化和后续重定位操作*/
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
-	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
+	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM (TEXT_BASE = 0x33F80000)*/
 	cmp     r0, r1                  /* don't reloc during debug         */
-	beq     stack_setup
-
+	beq     clear_bss
 	ldr	r2, _armboot_start
 	ldr	r3, _bss_start
 	sub	r2, r3, r2		/* r2 <- size of armboot            */
+
+	bl	CopyCode2Ram
+#if 0
 	add	r2, r0, r2		/* r2 <- source end address         */
 
 copy_loop:
@@ -177,18 +221,11 @@
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
-#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
-
-	/* Set up the stack						    */
-stack_setup:
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
-	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
-	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
-#ifdef CONFIG_USE_IRQ
-	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
 #endif
-	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
 
+#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
+
+	
 clear_bss:
 	ldr	r0, _bss_start		/* find start of bss segment        */
 	ldr	r1, _bss_end		/* stop here                        */
@@ -220,6 +257,15 @@
 	/* END stuff after relocation */
 #endif
 
+	//点亮led测试	
+	//ldr r0, =0x56000050
+	//ldr r1, =0x00001500
+	//str r1, [r0]
+	
+	//ldr r0, =0x56000054
+	//ldr r1, =0
+	//str r1, [r0]
+
 	ldr	pc, _start_armboot
 
 _start_armboot:	.word start_armboot
diff -urN u-boot-1.1.6/drivers/dm9000x.c uboot_1.1.6_lyb2440/drivers/dm9000x.c
--- u-boot-1.1.6/drivers/dm9000x.c	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/drivers/dm9000x.c	2019-12-06 02:08:46.365273062 -0800
@@ -17,17 +17,17 @@
   (C)Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.
 
 V0.11	06/20/2001	REG_0A bit3=1, default enable BP with DA match
-	06/22/2001 	Support DM9801 progrmming
-	 	 	E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
-		 	E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
-     		R17 = (R17 & 0xfff0) | NF + 3
-		 	E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
-     		R17 = (R17 & 0xfff0) | NF
+	06/22/2001	Support DM9801 progrmming
+			E3: R25 = ((R24 + NF) & 0x00ff) | 0xf000
+			E4: R25 = ((R24 + NF) & 0x00ff) | 0xc200
+		R17 = (R17 & 0xfff0) | NF + 3
+			E5: R25 = ((R24 + NF - 3) & 0x00ff) | 0xc200
+		R17 = (R17 & 0xfff0) | NF
 
-v1.00               	modify by simon 2001.9.5
+v1.00			modify by simon 2001.9.5
 	                change for kernel 2.4.x
 
-v1.1   11/09/2001      	fix force mode bug
+v1.1   11/09/2001	fix force mode bug
 
 v1.2   03/18/2003       Weilun Huang <weilun_huang@davicom.com.tw>:
 			Fixed phy reset.
@@ -36,7 +36,24 @@
 
 --------------------------------------
 
-       12/15/2003       Initial port to u-boot by Sascha Hauer <saschahauer@web.de>
+       12/15/2003       Initial port to u-boot by
+       			Sascha Hauer <saschahauer@web.de>
+
+       06/03/2008	Remy Bohmer <linux@bohmer.net>
+			- Fixed the driver to work with DM9000A.
+			  (check on ISR receive status bit before reading the
+			  FIFO as described in DM9000 programming guide and
+			  application notes)
+			- Added autodetect of databus width.
+			- Made debug code compile again.
+			- Adapt eth_send such that it matches the DM9000*
+			  application notes. Needed to make it work properly
+			  for DM9000A.
+			- Adapted reset procedure to match DM9000 application
+			  notes (i.e. double reset)
+			- some minor code cleanups
+			These changes are tested with DM9000{A,EP,E} together
+			with a 200MHz Atmel AT91SAM92161 core
 
 TODO: Homerun NIC and longrun NIC are not functional, only internal at the
       moment.
@@ -47,8 +64,6 @@
 #include <net.h>
 #include <asm/io.h>
 
-#ifdef CONFIG_DRIVER_DM9000
-
 #include "dm9000x.h"
 
 /* Board/System/Debug information/definition ---------------- */
@@ -59,10 +74,22 @@
 /* #define CONFIG_DM9000_DEBUG */
 
 #ifdef CONFIG_DM9000_DEBUG
-#define DM9000_DBG(fmt,args...) printf(fmt ,##args)
-#else				/*  */
+#define DM9000_DBG(fmt,args...) printf(fmt, ##args)
+#define DM9000_DMP_PACKET(func,packet,length)  \
+	do { \
+		int i; 							\
+		printf(func ": length: %d\n", length);			\
+		for (i = 0; i < length; i++) {				\
+			if (i % 8 == 0)					\
+				printf("\n%s: %02x: ", func, i);	\
+			printf("%02x ", ((unsigned char *) packet)[i]);	\
+		} printf("\n");						\
+	} while(0)
+#else
 #define DM9000_DBG(fmt,args...)
-#endif				/*  */
+#define DM9000_DMP_PACKET(func,packet,length)
+#endif
+
 enum DM9000_PHY_mode { DM9000_10MHD = 0, DM9000_100MHD =
 	    1, DM9000_10MFD = 4, DM9000_100MFD = 5, DM9000_AUTO =
 	    8, DM9000_1M_HPNA = 0x10
@@ -84,8 +111,11 @@
 	u8 device_wait_reset;	/* device state */
 	u8 nic_type;		/* NIC type */
 	unsigned char srom[128];
+	void (*outblk)(volatile void *data_ptr, int count);
+	void (*inblk)(void *data_ptr, int count);
+	void (*rx_status)(u16 *RxStatus, u16 *RxLen);
 } board_info_t;
-board_info_t dmfe_info;
+static board_info_t dm9000_info;
 
 /* For module input parameter */
 static int media_mode = DM9000_AUTO;
@@ -99,7 +129,7 @@
 static int dm9000_probe(void);
 static u16 phy_read(int);
 static void phy_write(int, u16);
-static u16 read_srom_word(int);
+u16 read_srom_word(int);
 static u8 DM9000_ior(int);
 static void DM9000_iow(int reg, u8 value);
 
@@ -124,10 +154,85 @@
 	DM9000_DBG("TSRII (0x04): %02x\n", DM9000_ior(4));
 	DM9000_DBG("RCR   (0x05): %02x\n", DM9000_ior(5));
 	DM9000_DBG("RSR   (0x06): %02x\n", DM9000_ior(6));
-	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(ISR));
+	DM9000_DBG("ISR   (0xFE): %02x\n", DM9000_ior(DM9000_ISR));
 	DM9000_DBG("\n");
 }
-#endif				/*  */
+#endif
+
+static void dm9000_outblk_8bit(volatile void *data_ptr, int count)
+{
+	int i;
+	for (i = 0; i < count; i++)
+		DM9000_outb((((u8 *) data_ptr)[i] & 0xff), DM9000_DATA);
+}
+
+static void dm9000_outblk_16bit(volatile void *data_ptr, int count)
+{
+	int i;	
+	//这里由于是16位的，一次传输2byte,所以n bytes数据传输n/2次
+	u32 tmplen = (count + 1) / 2;
+	for (i = 0; i < tmplen; i++)
+		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);//往数据总线写数据
+}
+static void dm9000_outblk_32bit(volatile void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 3) / 4;
+
+	for (i = 0; i < tmplen; i++)
+		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
+}
+
+static void dm9000_inblk_8bit(void *data_ptr, int count)
+{
+	int i;
+	for (i = 0; i < count; i++)
+		((u8 *) data_ptr)[i] = DM9000_inb(DM9000_DATA);
+}
+
+static void dm9000_inblk_16bit(void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 1) / 2;
+
+	for (i = 0; i < tmplen; i++)
+		((u16 *) data_ptr)[i] = DM9000_inw(DM9000_DATA);//从数据总线读数据
+}
+static void dm9000_inblk_32bit(void *data_ptr, int count)
+{
+	int i;
+	u32 tmplen = (count + 3) / 4;
+
+	for (i = 0; i < tmplen; i++)
+		((u32 *) data_ptr)[i] = DM9000_inl(DM9000_DATA);
+}
+
+static void dm9000_rx_status_32bit(u16 *RxStatus, u16 *RxLen)
+{
+	u32 tmpdata;
+
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	tmpdata = DM9000_inl(DM9000_DATA);
+	*RxStatus = tmpdata;
+	*RxLen = tmpdata >> 16;
+}
+
+static void dm9000_rx_status_16bit(u16 *RxStatus, u16 *RxLen)
+{
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);//MRCMD 命令
+
+	*RxStatus = DM9000_inw(DM9000_DATA); //包的第2字节表示状态
+	*RxLen = DM9000_inw(DM9000_DATA);    //包的第3字节表示长度
+}
+
+static void dm9000_rx_status_8bit(u16 *RxStatus, u16 *RxLen)
+{
+	DM9000_outb(DM9000_MRCMD, DM9000_IO);
+
+	*RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
+	*RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
+}
 
 /*
   Search DM9000 board, allocate space and register it
@@ -236,7 +341,7 @@
 static void
 identify_nic(void)
 {
-	struct board_info *db = &dmfe_info;	/* Point a board information structure */
+	struct board_info *db = &dm9000_info;
 	u16 phy_reg3;
 	DM9000_iow(DM9000_NCR, NCR_EXT_PHY);
 	phy_reg3 = phy_read(3);
@@ -263,9 +368,44 @@
 static void
 dm9000_reset(void)
 {
-	DM9000_DBG("resetting\n");
-	DM9000_iow(DM9000_NCR, NCR_RST);
-	udelay(1000);		/* delay 1ms */
+	DM9000_DBG("resetting DM9000\n");
+
+	/* Reset DM9000,
+	   see DM9000 Application Notes V1.22 Jun 11, 2004 page 29 */
+
+	/* DEBUG: Make all GPIO pins outputs */
+	DM9000_iow(DM9000_GPCR, 0x0F);	//GPCR是gpio控制寄存器，先配置gpio[0-3]为输出
+	
+	/* Step 1: Power internal PHY by writing 0 to GPIO0 pin */
+	/* DM9000A默认的休眠状态以降低功耗，因此需要首先唤醒PHY,
+	** GPR[0]=0，使GPIO0输出低电平以激活内部PHY
+	**/
+	DM9000_iow(DM9000_GPR, 0);	
+	/* Step 2: Software reset */
+	/* 两次软复位
+	**设置NCR[2：0]=011；至少保持20μs；?清除NCR[2：0]=000
+	**重复一次
+	*/
+	DM9000_iow(DM9000_NCR, 3);
+
+	do {
+		DM9000_DBG("resetting the DM9000, 1st reset\n");
+		udelay(25); /* Wait at least 20 us */
+	} while (DM9000_ior(DM9000_NCR) & 1);
+
+	DM9000_iow(DM9000_NCR, 0);
+	DM9000_iow(DM9000_NCR, 3); /* Issue a second reset */
+
+	do {
+		DM9000_DBG("resetting the DM9000, 2nd reset\n");
+		udelay(25); /* Wait at least 20 us */
+	} while (DM9000_ior(DM9000_NCR) & 1);
+
+	/* Check whether the ethernet controller is present */
+	/*reset完后可以进行访问下product ID*/
+	if ((DM9000_ior(DM9000_PIDL) != 0x0) ||
+	    (DM9000_ior(DM9000_PIDH) != 0x90))
+		printf("ERROR: resetting DM9000 -> not responding\n");
 }
 
 /* Initilize dm9000 board
@@ -274,34 +414,98 @@
 eth_init(bd_t * bd)
 {
 	int i, oft, lnk;
+	u8 io_mode;
+	struct board_info *db = &dm9000_info;
+
 	DM9000_DBG("eth_init()\n");
 
 	/* RESET device */
 	dm9000_reset();
+	
+	/*检测vendor   product ID对不对*/
 	dm9000_probe();
 
+	/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */
+	/*确定是总线位宽，ISR[7-6]是位宽*/
+	io_mode = DM9000_ior(DM9000_ISR) >> 6;
+
+	switch (io_mode) {
+	case 0x0:  /* 16-bit mode */
+		printf("DM9000: running in 16 bit mode\n");
+		db->outblk    = dm9000_outblk_16bit; /*写*/
+		db->inblk     = dm9000_inblk_16bit;  /*读*/
+		db->rx_status = dm9000_rx_status_16bit;
+		break;
+	case 0x01:  /* 32-bit mode */
+		printf("DM9000: running in 32 bit mode\n");
+		db->outblk    = dm9000_outblk_32bit;
+		db->inblk     = dm9000_inblk_32bit;
+		db->rx_status = dm9000_rx_status_32bit;
+		break;
+	case 0x02: /* 8 bit mode */
+		printf("DM9000: running in 8 bit mode\n");
+		db->outblk    = dm9000_outblk_8bit;
+		db->inblk     = dm9000_inblk_8bit;
+		db->rx_status = dm9000_rx_status_8bit;
+		break;
+	default:
+		/* Assume 8 bit mode, will probably not work anyway */
+		printf("DM9000: Undefined IO-mode:0x%x\n", io_mode);
+		db->outblk    = dm9000_outblk_8bit;
+		db->inblk     = dm9000_inblk_8bit;
+		db->rx_status = dm9000_rx_status_8bit;
+		break;
+	}
+
 	/* NIC Type: FASTETHER, HOMERUN, LONGRUN */
-	identify_nic();
+	identify_nic();//没什么用
 
 	/* GPIO0 on pre-activate PHY */
 	DM9000_iow(DM9000_GPR, 0x00);	/*REG_1F bit0 activate phyxcer */
-
-	/* Set PHY */
 	set_PHY_mode();
 
-	/* Program operating register */
-	DM9000_iow(DM9000_NCR, 0x0);	/* only intern phy supported by now */
-	DM9000_iow(DM9000_TCR, 0);	/* TX Polling clear */
-	DM9000_iow(DM9000_BPTR, 0x3f);	/* Less 3Kb, 200us */
-	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));	/* Flow Control : High/Low Water */
-	DM9000_iow(DM9000_FCR, 0x0);	/* SH FIXME: This looks strange! Flow Control */
-	DM9000_iow(DM9000_SMCR, 0);	/* Special Mode */
-	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);	/* clear TX status */
-	DM9000_iow(DM9000_ISR, 0x0f);	/* Clear interrupt status */
+	/* Program operating register, only intern phy supported by now */
+	DM9000_iow(DM9000_NCR, 0x0);//配置为正常模式
+	/* TX Polling clear */
+	DM9000_iow(DM9000_TCR, 0);
+	/* Less 3Kb, 200us */
+	DM9000_iow(DM9000_BPTR, 0x3f);
+	/* Flow Control : High/Low Water */
+	DM9000_iow(DM9000_FCTR, FCTR_HWOT(3) | FCTR_LWOT(8));
+	/* SH FIXME: This looks strange! Flow Control */
+	DM9000_iow(DM9000_FCR, 0x0);
+	/* Special Mode */
+	DM9000_iow(DM9000_SMCR, 0); //禁用特殊模式
+	
+	/* clear TX status */
+	/*清除发送状态，清除中断标志位
+	**设置NSR bit[5]=1?bit[3]=l?bit[2]=l
+	*/
+	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);
+	/* Clear interrupt status */
+	DM9000_iow(DM9000_ISR, 0x0f);
 
 	/* Set Node address */
+#ifndef CONFIG_AT91SAM9261EK
 	for (i = 0; i < 6; i++)
 		((u16 *) bd->bi_enetaddr)[i] = read_srom_word(i);
+#endif
+
+	if (is_zero_ether_addr(bd->bi_enetaddr) ||
+	    is_multicast_ether_addr(bd->bi_enetaddr)) {
+		/* try reading from environment */
+		u8 i;
+		char *s, *e;
+		s = getenv ("ethaddr");
+		for (i = 0; i < 6; ++i) {
+			bd->bi_enetaddr[i] = s ?
+				simple_strtoul (s, &e, 16) : 0;
+			if (s)
+				s = (*e) ? e + 1 : e;
+		}
+	}
+		
+	/*写入mac地址*/
 	printf("MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", bd->bi_enetaddr[0],
 	       bd->bi_enetaddr[1], bd->bi_enetaddr[2], bd->bi_enetaddr[3],
 	       bd->bi_enetaddr[4], bd->bi_enetaddr[5]);
@@ -316,8 +520,14 @@
 	DM9000_DBG("\n");
 
 	/* Activate DM9000 */
-	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);	/* RX enable */
-	DM9000_iow(DM9000_IMR, IMR_PAR);	/* Enable TX/RX interrupt mask */
+	/* RX enable */
+	/*设置RCR寄存器，使能数据接收功能*/
+	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
+	
+	/* Enable TX/RX interrupt mask */
+	/*启用RX／TX?FIFO?SRAM读／写地址指针自动返回功能*/
+	DM9000_iow(DM9000_IMR, IMR_PAR);
+
 	i = 0;
 	while (!(phy_read(1) & 0x20)) {	/* autonegation complete bit */
 		udelay(1000);
@@ -359,54 +569,41 @@
 int
 eth_send(volatile void *packet, int length)
 {
-	char *data_ptr;
-	u32 tmplen, i;
 	int tmo;
-	DM9000_DBG("eth_send: length: %d\n", length);
-	for (i = 0; i < length; i++) {
-		if (i % 8 == 0)
-			DM9000_DBG("\nSend: 02x: ", i);
-		DM9000_DBG("%02x ", ((unsigned char *) packet)[i]);
-	} DM9000_DBG("\n");
-
-	/* Move data to DM9000 TX RAM */
-	data_ptr = (char *) packet;
-	DM9000_outb(DM9000_MWCMD, DM9000_IO);
+	struct board_info *db = &dm9000_info;
 
-#ifdef CONFIG_DM9000_USE_8BIT
-	/* Byte mode */
-	for (i = 0; i < length; i++)
-		DM9000_outb((data_ptr[i] & 0xff), DM9000_DATA);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	tmplen = (length + 1) / 2;
-	for (i = 0; i < tmplen; i++)
-		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
+	DM9000_DMP_PACKET("eth_send", packet, length);
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmplen = (length + 3) / 4;
-	for (i = 0; i < tmplen; i++)
-		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
+	//1.清除发送中断
+	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */
 
-#endif				/*  */
+	/* Move data to DM9000 TX RAM */
+	DM9000_outb(DM9000_MWCMD, DM9000_IO); /* 将Memory Write CMD发送到ADD上 */
+	/* push the data to the TX-fifo */
+	(db->outblk)(packet, length); //启动发送，至于什么时候发完，要读状态寄存器
 
+	//将发送长度写入
 	/* Set TX length to DM9000 */
 	DM9000_iow(DM9000_TXPLL, length & 0xff);
 	DM9000_iow(DM9000_TXPLH, (length >> 8) & 0xff);
 
 	/* Issue TX polling command */
-	DM9000_iow(DM9000_TCR, TCR_TXREQ);	/* Cleared after TX complete */
+	/*开启发送开关，push开始进行*/
+	DM9000_iow(DM9000_TCR, TCR_TXREQ); /* Cleared after TX complete */
 
 	/* wait for end of transmission */
+	//等待数据发送完成
 	tmo = get_timer(0) + 5 * CFG_HZ;
-	while (DM9000_ior(DM9000_TCR) & TCR_TXREQ) {
+	while ( !(DM9000_ior(DM9000_NSR) & (NSR_TX1END | NSR_TX2END)) ||
+		!(DM9000_ior(DM9000_ISR) & IMR_PTM) ) {
 		if (get_timer(0) >= tmo) {
 			printf("transmission timeout\n");
 			break;
 		}
 	}
+	//清除发送中断
+	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */
+
 	DM9000_DBG("transmit done\n\n");
 	return 0;
 }
@@ -435,86 +632,77 @@
 {
 	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
 	u16 RxStatus, RxLen = 0;
-	u32 tmplen, i;
-#ifdef CONFIG_DM9000_USE_32BIT
-	u32 tmpdata;
-#endif
+	struct board_info *db = &dm9000_info;
 
-	/* Check packet ready or not */
-	DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
-	rxbyte = DM9000_inb(DM9000_DATA);	/* Got most updated data */
-	if (rxbyte == 0)
+	/* Check packet ready or not, we must check
+	   the ISR status first for DM9000A */
+	//ISR[0] =1 表示有数据接收到
+	if (!(DM9000_ior(DM9000_ISR) & 0x01)) /* Rx-ISR bit must be set. */
 		return 0;
 
-	/* Status check: this byte must be 0 or 1 */
-	if (rxbyte > 1) {
-		DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
-		DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
-		DM9000_DBG("rx status check: %d\n", rxbyte);
-	}
-	DM9000_DBG("receiving packet\n");
-
-	/* A packet ready now  & Get status/length */
-	DM9000_outb(DM9000_MRCMD, DM9000_IO);
-
-#ifdef CONFIG_DM9000_USE_8BIT
-	RxStatus = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
-	RxLen = DM9000_inb(DM9000_DATA) + (DM9000_inb(DM9000_DATA) << 8);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	RxStatus = DM9000_inw(DM9000_DATA);
-	RxLen = DM9000_inw(DM9000_DATA);
+	DM9000_iow(DM9000_ISR, 0x01); /* clear PR status latched in bit 0 */
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmpdata = DM9000_inl(DM9000_DATA);
-	RxStatus = tmpdata;
-	RxLen = tmpdata >> 16;
+	/* There is _at least_ 1 package in the fifo, read them all */
+	/*	数据帧结构
+	** ---------------------------------------------------------------------------
+	** | byte1(有无数据标志) | byte2(状态位) |byte3 byte4(帧长度)|	data	|.....
+	** ---------------------------------------------------------------------------
+	**                      第一帧，										 后续帧
+	*/
+	for (;;) {
+		//通过MRCMDX读数据包的第一个字节，并辨别其后是否有数据包
+		DM9000_ior(DM9000_MRCMDX);	/* Dummy read */
+
+		/* Get most updated data,
+		   only look at bits 0:1, See application notes DM9000 */
+		rxbyte = DM9000_inb(DM9000_DATA) & 0x03;
+
+		/* Status check: this byte must be 0 or 1 */
+		if (rxbyte > DM9000_PKT_RDY) {
+			//异常，如果第一个字节既不是01H，也不是00H，DM9000A就必须作一次软复位来从这种异常状态中恢复
+			DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
+			DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
+			printf("DM9000 error: status check fail: 0x%x\n",
+				rxbyte);
+			return 0;
+		}
 
-#endif				/*  */
-	DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+		if (rxbyte != DM9000_PKT_RDY)//无数据
+			return 0; /* No packet received, ignore */
 
-	/* Move data from DM9000 */
-	/* Read received packet from RX SRAM */
-#ifdef CONFIG_DM9000_USE_8BIT
-	for (i = 0; i < RxLen; i++)
-		rdptr[i] = DM9000_inb(DM9000_DATA);
-
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_16BIT
-	tmplen = (RxLen + 1) / 2;
-	for (i = 0; i < tmplen; i++)
-		((u16 *) rdptr)[i] = DM9000_inw(DM9000_DATA);
+		DM9000_DBG("receiving packet\n");
 
-#endif				/*  */
-#ifdef CONFIG_DM9000_USE_32BIT
-	tmplen = (RxLen + 3) / 4;
-	for (i = 0; i < tmplen; i++)
-		((u32 *) rdptr)[i] = DM9000_inl(DM9000_DATA);
+		/* A packet ready now  & Get status/length */
+		//dm9000_rx_status_16bit 获取长度状态
+		(db->rx_status)(&RxStatus, &RxLen);
+		
+		DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);
+
+		/* Move data from DM9000 */
+		/* Read received packet from RX SRAM */
+		(db->inblk)(rdptr, RxLen); //dm9000_inblk_16bit 从数据总线拿数据
+
+		if ((RxStatus & 0xbf00) || (RxLen < 0x40)
+			|| (RxLen > DM9000_PKT_MAX)) {
+			if (RxStatus & 0x100) {
+				printf("rx fifo error\n");
+			}
+			if (RxStatus & 0x200) {
+				printf("rx crc error\n");
+			}
+			if (RxStatus & 0x8000) {
+				printf("rx length error\n");
+			}
+			if (RxLen > DM9000_PKT_MAX) {
+				printf("rx length too big\n");
+				dm9000_reset();
+			}
+		} else {
+			DM9000_DMP_PACKET("eth_rx", rdptr, RxLen);
 
-#endif				/*  */
-	if ((RxStatus & 0xbf00) || (RxLen < 0x40)
-	    || (RxLen > DM9000_PKT_MAX)) {
-		if (RxStatus & 0x100) {
-			printf("rx fifo error\n");
-		}
-		if (RxStatus & 0x200) {
-			printf("rx crc error\n");
+			DM9000_DBG("passing packet to upper layer\n");
+			NetReceive(NetRxPackets[0], RxLen);//rdptr = NetRxPackets[0](数据就在这儿)，
 		}
-		if (RxStatus & 0x8000) {
-			printf("rx length error\n");
-		}
-		if (RxLen > DM9000_PKT_MAX) {
-			printf("rx length too big\n");
-			dm9000_reset();
-		}
-	} else {
-
-		/* Pass to upper layer */
-		DM9000_DBG("passing packet to upper layer\n");
-		NetReceive(NetRxPackets[0], RxLen);
-		return RxLen;
 	}
 	return 0;
 }
@@ -522,16 +710,28 @@
 /*
   Read a word data from SROM
 */
-static u16
+u16
 read_srom_word(int offset)
 {
 	DM9000_iow(DM9000_EPAR, offset);
 	DM9000_iow(DM9000_EPCR, 0x4);
-	udelay(200);
+	udelay(8000);
 	DM9000_iow(DM9000_EPCR, 0x0);
 	return (DM9000_ior(DM9000_EPDRL) + (DM9000_ior(DM9000_EPDRH) << 8));
 }
 
+void
+write_srom_word(int offset, u16 val)
+{
+	DM9000_iow(DM9000_EPAR, offset);
+	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
+	DM9000_iow(DM9000_EPDRL, (val & 0xff));
+	DM9000_iow(DM9000_EPCR, 0x12);
+	udelay(8000);
+	DM9000_iow(DM9000_EPCR, 0);
+}
+
+
 /*
    Read a byte from I/O port
 */
@@ -563,12 +763,12 @@
 	/* Fill the phyxcer register into REG_0C */
 	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
 	DM9000_iow(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
-	udelay(100);		/* Wait read complete */
+	udelay(100);			/* Wait read complete */
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer read command */
 	val = (DM9000_ior(DM9000_EPDRH) << 8) | DM9000_ior(DM9000_EPDRL);
 
 	/* The read data keeps on REG_0D & REG_0E */
-	DM9000_DBG("phy_read(%d): %d\n", reg, val);
+	DM9000_DBG("phy_read(0x%x): 0x%x\n", reg, val);
 	return val;
 }
 
@@ -580,14 +780,17 @@
 {
 
 	/* Fill the phyxcer register into REG_0C */
-	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
-
+	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);//发地址
+	
 	/* Fill the written data into REG_0D & REG_0E */
-	DM9000_iow(DM9000_EPDRL, (value & 0xff));
-	DM9000_iow(DM9000_EPDRH, ((value >> 8) & 0xff));
+	DM9000_iow(DM9000_EPDRL, (value & 0xff));//发数据低8位
+	DM9000_iow(DM9000_EPDRH, ((value >> 8) & 0xff));//发数据高8位
+
+	//启动写
 	DM9000_iow(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
-	udelay(500);		/* Wait write complete */
+	udelay(500);			/* Wait write complete */
+
+	//写完成清除写命令
 	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
-	DM9000_DBG("phy_write(reg:%d, value:%d)\n", reg, value);
+	DM9000_DBG("phy_write(reg:0x%x, value:0x%x)\n", reg, value);
 }
-#endif				/* CONFIG_DRIVER_DM9000 */
diff -urN u-boot-1.1.6/include/asm-arm/mach-types.h uboot_1.1.6_lyb2440/include/asm-arm/mach-types.h
--- u-boot-1.1.6/include/asm-arm/mach-types.h	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/include/asm-arm/mach-types.h	2019-12-05 17:47:55.213691591 -0800
@@ -206,6 +206,8 @@
 #define MACH_TYPE_FESTER               191
 #define MACH_TYPE_GPI                  192
 #define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_SMDK2440             799
+
 #define MACH_TYPE_I519                 194
 #define MACH_TYPE_NEXIO                195
 #define MACH_TYPE_BITBOX               196
diff -urN u-boot-1.1.6/include/configs/lyb2440.h uboot_1.1.6_lyb2440/include/configs/lyb2440.h
--- u-boot-1.1.6/include/configs/lyb2440.h	1969-12-31 16:00:00.000000000 -0800
+++ uboot_1.1.6_lyb2440/include/configs/lyb2440.h	2019-12-05 17:47:55.213691591 -0800
@@ -0,0 +1,232 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <gj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * Configuation settings for the SAMSUNG SMDK2410 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_ARM920T		1	/* This is an ARM920T Core	*/
+#define	CONFIG_S3C2410		1	/* in a SAMSUNG S3C2410 SoC     */
+#define CONFIG_S3C2440		1
+#define CONFIG_SMDK2410		1	/* on a SAMSUNG SMDK2410 Board  */
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	12000000/* the SMDK2410 has 12MHz input clock */
+
+
+#define USE_920T_MMU		1
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
+
+/*
+**	使能mtd和jffs功能
+*/
+#define CONFIG_JFFS2_CMDLINE 1
+#define CONFIG_JFFS2_NAND    1
+
+#define MTDIDS_DEFAULT		"nand0=nandflash0"
+#define MTDPARTS_DEFAULT	"mtdparts=nandflash0:256k@0(bootloader)," \
+							"128k(params)," \
+							"2m(kernel)," \
+							"-(root)"
+							
+//添加额外的环境变量（nand相关）
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"mtdids="		MTDIDS_DEFAULT			"\0" \
+		"mtdparts="		MTDPARTS_DEFAULT		"\0"
+		
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + 128*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Hardware drivers
+ */
+//======================================= 网卡 DM9000 ===============================================//
+# if 0
+#define CONFIG_DRIVER_CS8900	1	/* we have a CS8900 on-board */
+#define CS8900_BASE		0x19000300
+#define CS8900_BUS16		1 /* the Linux driver does accesses as shorts */
+#endif
+/*
+**由于DM9000只有一条地址线CMD,用于区别是数据还是地址（CMD为低时数据总线上传输的是地址信号，CMD为高时传输的是数据信号），
+**所以DM9000_DATA为0x20000004，DM9000_IO为0x20000000。
+*/
+#define CONFIG_DRIVER_DM9000		1
+#define CONFIG_DM9000_BASE			0x20000000
+#define DM9000_IO					CONFIG_DM9000_BASE
+#define DM9000_DATA					(CONFIG_DM9000_BASE + 4)
+
+#define CONFIG_DM9000_USE_16BIT   	1
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK2410 */
+
+/************************************************************
+ * RTC
+ ************************************************************/
+#define	CONFIG_RTC_S3C24X0	1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define CONFIG_COMMANDS \
+			(CONFIG_CMD_DFL	 | \
+			CFG_CMD_CACHE	 | \
+			CFG_CMD_JFFS2	 | \
+			CFG_CMD_NAND	 | \
+			CFG_CMD_PING	 | \
+			/*CFG_CMD_EEPROM |*/ \
+			/*CFG_CMD_I2C	 |*/ \
+			/*CFG_CMD_USB	 |*/ \
+			CFG_CMD_REGINFO  | \
+			CFG_CMD_DATE	 | \
+			CFG_CMD_ELF)
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#define CONFIG_BOOTDELAY	3
+#define CONFIG_BOOTARGS    	"root=ramfs devfs=mount console=ttySA0,9600" 
+#define CONFIG_ETHADDR		08:00:3e:26:0a:5b
+#define CONFIG_NETMASK          255.255.255.0
+#define CONFIG_IPADDR		192.168.1.10
+#define CONFIG_SERVERIP		192.168.1.11
+/*#define CONFIG_BOOTFILE	"elinos-lart" */
+#define CONFIG_BOOTCOMMAND	"nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0"
+
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define	CFG_LONGHELP				/* undef to save memory		*/
+#define	CFG_PROMPT		"lyb2440 # "	/* Monitor Command Prompt	*/
+#define	CFG_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size */
+#define	CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CFG_MEMTEST_START	0x30000000	/* memtest works on	*/
+#define CFG_MEMTEST_END		0x33F00000	/* 63 MB in DRAM	*/
+
+#undef  CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define	CFG_LOAD_ADDR		0x33000000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 15625 for 10 ms, so we need */
+/* it to wrap 100 times (total 1562500) to get 1 sec. */
+#define	CFG_HZ			1562500
+
+/* valid baudrates */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+//=======================================sdram 配置===============================================//
+#define CONFIG_NR_DRAM_BANKS	1	   /* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x30000000 /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x04000000 /* 64 MB */
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+ //=======================================nor 配置===============================================//
+
+#define CONFIG_AMD_LV400	1	/* uncomment this if you have a LV400 flash */
+#if 0
+#define CONFIG_AMD_LV800	1	/* uncomment this if you have a LV800 flash */
+#endif
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+#ifdef CONFIG_AMD_LV800
+#define PHYS_FLASH_SIZE		0x00100000 /* 1MB */
+#define CFG_MAX_FLASH_SECT	(19)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x0F0000) /* addr of environment */
+#endif
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CFG_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+//#define	CFG_ENV_IS_IN_FLASH	1 /*nor存放环境变量*/
+//#define CFG_ENV_SIZE		0x10000	/* Total Size of Environment Sector */
+
+//=======================================nand 配置===============================================//
+//修改成nand中存放环境变量
+#define CFG_ENV_IS_IN_NAND		1
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + 0x40000) /* addr of environment at 256K */
+#define CFG_ENV_OFFSET			0x40000 	/* Environment offset */
+#define CFG_ENV_SIZE			0x20000		/* Environment Size 128K */
+#define CFG_MONITOR_BASE		CFG_ENV_ADDR
+
+/*-----------------------------------------------------------------------
+ * NAND flash settings
+ */
+#define CFG_NAND_BASE           0
+#define CFG_MAX_NAND_DEVICE     1
+#define NAND_MAX_CHIPS          1
+
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-1.1.6/include/net.h uboot_1.1.6_lyb2440/include/net.h
--- u-boot-1.1.6/include/net.h	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/include/net.h	2019-12-05 17:47:55.213691591 -0800
@@ -435,6 +435,29 @@
 	memcpy((void*)to, (void*)from, sizeof(ulong));
 }
 
+/**
+ * is_zero_ether_addr - Determine if give Ethernet address is all zeros.
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Return true if the address is all zeroes.
+ */
+static inline int is_zero_ether_addr(const u8 *addr)
+{
+	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+
+/**
+ * is_multicast_ether_addr - Determine if the Ethernet address is a multicast.
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Return true if the address is a multicast address.
+ * By definition the broadcast address is also a multicast address.
+ */
+static inline int is_multicast_ether_addr(const u8 *addr)
+{
+	return (0x01 & addr[0]);
+}
+
 /* Convert an IP address to a string */
 extern void	ip_to_string (IPaddr_t x, char *s);
 
diff -urN u-boot-1.1.6/include/s3c2410.h uboot_1.1.6_lyb2440/include/s3c2410.h
--- u-boot-1.1.6/include/s3c2410.h	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/include/s3c2410.h	2019-12-05 17:47:55.213691591 -0800
@@ -52,6 +52,8 @@
 #define S3C24X0_CLOCK_POWER_BASE	0x4C000000
 #define S3C24X0_LCD_BASE		0x4D000000
 #define S3C2410_NAND_BASE		0x4E000000
+#define S3C2440_NAND_BASE		S3C2410_NAND_BASE
+
 #define S3C24X0_UART_BASE		0x50000000
 #define S3C24X0_TIMER_BASE		0x51000000
 #define S3C24X0_USB_DEVICE_BASE		0x52000140
@@ -97,6 +99,16 @@
 {
 	return (S3C2410_NAND * const)S3C2410_NAND_BASE;
 }
+
+#ifdef CONFIG_S3C2440
+static inline S3C2410_NAND * const S3C2440_GetBase_NAND(void)
+{
+	return (S3C2440_NAND * const)S3C2440_NAND_BASE;
+}
+#endif
+
+
+
 static inline S3C24X0_UART * const S3C24X0_GetBase_UART(S3C24X0_UARTS_NR nr)
 {
 	return (S3C24X0_UART * const)(S3C24X0_UART_BASE + (nr * 0x4000));
diff -urN u-boot-1.1.6/include/s3c24x0.h uboot_1.1.6_lyb2440/include/s3c24x0.h
--- u-boot-1.1.6/include/s3c24x0.h	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/include/s3c24x0.h	2019-12-05 17:47:55.213691591 -0800
@@ -164,6 +164,27 @@
 	S3C24X0_REG32	NFECC;
 } /*__attribute__((__packed__))*/ S3C2410_NAND;
 
+#ifdef CONFIG_S3C2440
+/* NAND FLASH (see S3C2440 manual chapter 6) 添加2440nand控制器*/
+typedef struct {
+    S3C24X0_REG32   NFCONF;
+    S3C24X0_REG32   NFCONT;
+    S3C24X0_REG32   NFCMD;
+    S3C24X0_REG32   NFADDR;
+    S3C24X0_REG32   NFDATA;
+    S3C24X0_REG32   NFMECCD0;
+    S3C24X0_REG32   NFMECCD1;
+    S3C24X0_REG32   NFSECCD;
+    S3C24X0_REG32   NFSTAT;
+    S3C24X0_REG32   NFESTAT0;
+    S3C24X0_REG32   NFESTAT1;
+    S3C24X0_REG32   NFMECC0;
+    S3C24X0_REG32   NFMECC1;
+    S3C24X0_REG32   NFSECC;
+    S3C24X0_REG32   NFSBLK;
+    S3C24X0_REG32   NFEBLK;
+} /*__attribute__((__packed__))*/ S3C2440_NAND;
+#endif
 
 /* UART (see manual chapter 11) */
 typedef struct {
diff -urN u-boot-1.1.6/lib_arm/board.c uboot_1.1.6_lyb2440/lib_arm/board.c
--- u-boot-1.1.6/lib_arm/board.c	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/lib_arm/board.c	2019-12-05 17:47:55.213691591 -0800
@@ -233,6 +233,58 @@
 	NULL,
 };
 
+void lyb_delay(volatile int d)
+{
+	while (d--);
+}
+
+#define	GPFCON 		(*(volatile unsigned int *)0x56000050)
+#define	GPFDAT  	(*(volatile unsigned int *)0x56000054)
+#define	GPHCON		(*(volatile unsigned int *)0x56000070)
+#define	GPHUP		(*(volatile unsigned int *)0x56000078)
+
+#define	UCON0		(*(volatile unsigned int *)0x50000004)
+#define	UBRDIV0		(*(volatile unsigned int *)0x50000028)
+#define	ULCON0		(*(volatile unsigned int *)0x50000000)
+#define	UTRSTAT0		(*(volatile unsigned int *)0x50000010)
+#define	UTXH0		(*(volatile unsigned int *)0x50000020)
+int led_test(void)
+{
+	int val = 0;  /* val: 0b000, 0b111 */
+	int tmp;
+	int i=50;
+
+	/* 设置GPFCON让GPF4/5/6配置为输出引脚 */
+	GPFCON &= ~((3<<8) | (3<<10) | (3<<12));
+	GPFCON |=  ((1<<8) | (1<<10) | (1<<12));
+
+	/* 循环点亮 */
+	while (--i)
+	{
+		tmp = ~val;
+		tmp &= 7;
+		GPFDAT &= ~(7<<4);
+		GPFDAT |= (tmp<<4);
+		lyb_delay(100000);
+		val++;
+		if (val == 8)
+			val =0;
+		
+	}
+
+	return 0;
+}
+
+int lyb_putchar(int c)
+{
+	/* UTRSTAT0 */
+	/* UTXH0 */
+
+	while (!(UTRSTAT0 & (1<<2)));
+	UTXH0 = (unsigned char)c;
+	return 0;
+}
+
 void start_armboot (void)
 {
 	init_fnc_t **init_fnc_ptr;
@@ -244,23 +296,46 @@
 	unsigned long addr;
 #endif
 
+	GPFCON &= ~((3<<8) | (3<<10) | (3<<12));
+	GPFCON |=  ((1<<8) | (1<<10) | (1<<12));
+	
 	/* Pointer is writable since we allocated a register for it */
 	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
+	
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("": : :"memory");
-
 	memset ((void*)gd, 0, sizeof (gd_t));
+	GPFDAT &= ~(7<<4);
 	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
+	GPFDAT |= 3<<4;
 	memset (gd->bd, 0, sizeof (bd_t));
-
+	GPFDAT |= 7<<4;
 	monitor_flash_len = _bss_start - _armboot_start;
 
+/*
+	GPHCON &= ~((3<<4) | (3<<6));
+	GPHCON |= ((2<<4) | (2<<6));
+	GPHUP &= ~((1<<2) | (1<<3));  // 使能内部上拉 
+	UCON0 = 0x00000005; //PCLK,中断/查询模式 
+	UBRDIV0 = 26;
+
+	//设置数据格式 
+	ULCON0 = 0x00000003; // 8n1: 8个数据位, 无较验位, 1个停止位 
+
+	GPFDAT &= ~(7<<4);
+
+	lyb_putchar('l');
+	lyb_putchar('y');
+	lyb_putchar('b');*/
+	GPFDAT |= 1<<4;
+	
 	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
 		if ((*init_fnc_ptr)() != 0) {
 			hang ();
 		}
 	}
 
+	led_test();
 #ifndef CFG_NO_FLASH
 	/* configure available FLASH banks */
 	size = flash_init ();
@@ -384,6 +459,10 @@
 	}
 #endif	/* CFG_CMD_NET */
 
+	//add by fuzidage， 初始化网卡dm9000
+	eth_init(gd->bd);
+
+
 #ifdef BOARD_LATE_INIT
 	board_late_init ();
 #endif
@@ -393,6 +472,8 @@
 #endif
 	eth_initialize(gd->bd);
 #endif
+	puts ("### main_loop start enter... ###\n\r");
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop ();
diff -urN u-boot-1.1.6/Makefile uboot_1.1.6_lyb2440/Makefile
--- u-boot-1.1.6/Makefile	2006-11-02 06:15:01.000000000 -0800
+++ uboot_1.1.6_lyb2440/Makefile	2019-12-05 17:47:55.213691591 -0800
@@ -1878,6 +1878,9 @@
 
 smdk2410_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
+	
+lyb2440_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t lyb2440 NULL s3c24x0
 
 SX1_config :		unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t sx1
